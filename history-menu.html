<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-ripple/paper-ripple.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<link rel="import" href="../iron-list/iron-list.html">
<link rel="import" href="../iron-scroll-target-behavior/iron-scroll-target-behavior.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../http-method-label/http-method-label.html">
<link rel="import" href="../openable-panel-behavior/openable-panel-behavior.html">
<link rel="import" href="../app-pouchdb/pouchdb.html">
<!--
A list of history items in the ARC main menu.

The element uses direct implementation of the PouchDB to make a query to the
datastore. It also listens to events fired by the `arc-model` elements to
update state of the history items.

### Example
```
<history-menu></history-menu>
```

### Sizing the element

The element uses `<iron-list>` to render the data in the view. The list is set
to be flex vertically. It means that the element has to be sized directly by the
hosting application or otherwise it size will be 0px.

It can be done using flex layout and making the element to be `flex: 1`.

### Styling
`<history-menu>` provides the following custom properties and mixins for styling:

Custom property | Description | Default
----------------|-------------|----------
`--history-menu` | Mixin applied to the element | `{}`
`--history-menu-background-color` | Background color of the menu | `#f7f7f7`
`--history-menu-selected-post-method-color` | Font color of selected item POST method label | `#fff`
`--history-menu-focused-post-method-color` | Font color of focused item POST method label | `rgb(33, 150, 243)`
`--history-menu-selected-method-label-background-color` | Background color of the POST method label when the item is focused | `#fff`
`--history-menu-list` | Mixin applied to the list element. | `{}`
`--history-menu-list-item` | Mixin applied to each list item | `{}`
`--history-menu-selected-item-background-color` | Background color of the selected list item | `#FF9800`
`--history-menu-selected-item-color` | Color of the selected list item | `#fff`
`--history-menu-url-label` | Mixin applied to the URL label | `{}`
`--history-menu-group-header` | Mixin applied to the history list group header | `{}`
`--history-menu-group-header-font-weigth` | Group header border color |  `bold`
`--history-menu-group-header-border-color` | Group header border color | `#ddd`
`--history-menu-group-header-color` | Font color of the group header` | `rgba(0, 0, 0, 0.54)`

@group UI Elements
@element history-menu
@demo demo/index.html
-->
<dom-module id="history-menu">
  <template>
    <style>
     :host {
      display: block;
      background-color: var(--history-menu-background-color, #f7f7f7);
      position: relative;
      @apply --layout-flex;
      @apply --layout-vertical;
      @apply --history-menu;
    }

    paper-item:focus http-method-label[method="post"] {
      color: var(--history-menu-selected-post-method-color, #fff);
    }

    .iron-selected paper-item:focus http-method-label[method="post"] {
      color: var(--history-menu-focused-post-method-color, rgb(33, 150, 243));
    }

    .iron-selected http-method-label {
      background-color: var(--history-menu-selected-method-label-background-color, #fff);
    }

    http-method-label {
      margin-right: 8px;
      font-size: 14px;
    }

    iron-list {
      flex: 1 1 auto;
      @apply --history-menu-list;
    }

    paper-item {
      @apply --arc-font-menu;
      font-weight: 400;
      min-height: 36px;
      cursor: pointer;
      @apply --history-menu-list-item;
    }

    .iron-selected paper-item {
      background-color: var(--history-menu-selected-item-background-color, #FF9800);
      color: var(--history-menu-selected-item-color, #fff);
    }

    .url {
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      font-size: 14px;
      @apply --history-menu-url-label;
    }

    .group-header {
      font-weight: var(--history-menu-group-header-font-weigth, bold);
      border-bottom: 1px solid var(--history-menu-group-header-border-color, #ddd);
      color: var(--history-menu-group-header-color, rgba(0, 0, 0, 0.54));
      padding: 12px 16px;
      @apply --history-menu-group-header;
    }

    paper-progress {
      width: calc(100% - 32px);
      margin: 0 16px;
      position: absolute;
    }

    .empty-info {
      @apply --arc-font-body1;
      font-style: italic;
      margin: 1em 16px;
    }

    .empty-title {
      @apply --paper-font-title;
      white-space: normal;
    }

    .empty-message {
      @apply --layout-flex;
      @apply --layout-vertical;
      @apply --layout-center-center;
      text-align: center;
    }

    .empty-state-image {
      width: 180px;
      height: 120px;
    }
    
    [hidden] {
      display: none !important;
    }
    </style>
    <paper-progress hidden$="[[!querying]]" indeterminate></paper-progress>
    <template is="dom-if" if="[[dataUnavailable]]">
      <div class="empty-message">
        <h3 class="empty-title">Send a request and recall it from here</h3>
        <svg class="empty-state-image" viewBox="0 0 180 120">
          <defs><style>
          .c1 {fill: #4d4d4d;}
          .c2 {fill: #666;}
          .c3 {fill: #faa;}
          .c4 {fill: red;}
          </style></defs>
          <g><rect class="c1" width="180" height="120" /></g>
          <rect class="c2" x="49" width="131" height="120" />
          <rect class="c2" x="4" y="5" width="41" height="7" />
          <rect class="c2" x="4" y="107.97" width="41" height="7" />
          <rect class="c2" x="4" y="22" width="35.53" height="7" />
          <rect class="c3" x="4" y="47.33" width="41" height="7" />
          <rect class="c4" x="4" y="47.33" width="9" height="7" />
          <rect class="c3" x="4" y="62.67" width="41" height="7" />
          <rect class="c4" x="4" y="62.67" width="9" height="7" />
          <rect class="c3" x="4" y="78" width="41" height="7" />
          <rect class="c4" x="4" y="78" width="9" height="7" />
        </svg>
        <p class="empty-info">Once you made a request it will appear in this place.</p>
      </div>
    </template>
    <iron-list items="[[items]]" id="list" hidden$="[[!hasItems]]">
      <template>
        <div data-index$="[[index]]" title$="[[item.url]]" class$="[[_computeItemClass(item._id, selectedItem)]]">
          <template is="dom-if" if="[[item.hasHeader]]">
            <div class="group-header">[[item.header]]</div>
          </template>
          <paper-item on-tap="_openHistory">
            <http-method-label method="[[item.method]]"></http-method-label>
            <span class="url">[[item.url]]</span>
            <paper-ripple></paper-ripple>
          </paper-item>
        </div>
      </template>
    </iron-list>
  </template>
  <script>
  Polymer({
    is: 'history-menu',

    behaviors: [
      Polymer.IronScrollTargetBehavior,
      Polymer.IronResizableBehavior,
      ArcBehaviors.OpenablePanelBehavior
    ],

    properties: {
      /**
       * History items found in the datastore.
       */
      items: Array,
      // Database ID of the selected item.
      selectedItem: String,
      // True when the element is querying the database for the data.
      querying: {
        type: Boolean,
        readOnly: true,
        notify: true
      },
      // Computed value, true if the `items` property has values.
      hasItems: {
        type: Boolean,
        value: false,
        computed: '_computeHasItems(items.length)',
        notify: true
      },
      /**
       * Database query options for pagination.
       * Override this value to change the query options like limit of the results in one call.
       *
       * This is query options passed to the PouchDB `allDocs` function. Note that it will not
       * set `include_docs` option. A conviniet shortcut is to set the the `includeDocs` property
       * and the directive will be added automatically.
       */
      queryOptions: {
        type: Object,
        readOnly: true,
        value: function() {
          return {
            limit: 25,
            descending: true,
            // jscs:disable
            include_docs: true
            // jscs:enable
          };
        }
      },
      // Element's scroll target
      scrollTarget: {
        type: Object,
        value: function() {
          return this.$.list;
        }
      },
      /**
       * Computed value. True if query ended and there's no results.
       */
      dataUnavailable: {
        type: Boolean,
        computed: '_computeDataUnavailable(hasItems, querying)'
      },
      // Event target for the model.
      _eventTarget: {
        type: Object,
        value: function() {
          return this;
        }
      }
    },
    // Returns a handler to the datastore instance
    get _db() {
      return new PouchDB('history-requests');
    },

    observers: [
      '_resetOnClosed(_isOpened)',
    ],

    attached: function() {
      this.listen(window, 'history-object-changed', '_historyChanged');
      this.listen(window, 'request-object-changed', '_requestChanged');
      this.listen(window, 'request-object-deleted', '_requestDeleted');
      this.listen(window, 'data-imported', 'refresh');
      this.listen(window, 'datastore-destroyed', '_onDatabaseDestroy');
    },

    detached: function() {
      this.unlisten(window, 'history-object-changed', '_historyChanged');
      this.unlisten(window, 'request-object-changed', '_requestChanged');
      this.unlisten(window, 'request-object-deleted', '_requestDeleted');
      this.unlisten(window, 'data-imported', 'refresh');
      this.unlisten(window, 'datastore-destroyed', '_onDatabaseDestroy');
    },
    /**
     * Resets the state of the variables.
     */
    reset: function() {
      if (this.queryOptions) {
        delete this.queryOptions.startkey;
        delete this.queryOptions.skip;
      }
      this._setQuerying(false);
      this.set('items', []);
      this.set('selectedItemIndex', -1);
    },
    /**
     * Refreshes the data from the datastore.
     * It resets the query options, clears items and makes a query to the datastore.
     */
    refresh: function() {
      this.reset();
      this.makeQuery();
    },

    _resetOnClosed: function(_isOpened) {
      if (_isOpened && !this.items && !this.querying) {
        this.makeQuery();
      }
    },
    // Handler for the `request-object-changed` event. This supports old API
    // and soon it should be replaced with `request-object-changed` event.
    _historyChanged: function(e) {
      var id = e.detail.id;
      var doc = e.detail.item;
      this._processItemChanged(id, doc);
    },
    // Handler for the `request-object-changed`
    _requestChanged: function(e) {
      if (e.cancelable) {
        return;
      }
      if (e.detail.type !== 'history-requests') {
        return;
      }
      this._processItemChanged(e.detail.request._id, e.detail.request);
    },
    /**
     * Processes updated request / history item.
     * If the request object is already on the list it will update the object.
     * Otherwise the object will be added to the list.
     *
     * @param {String} id Database ID of updated object
     * @param {Object} doc Database object.
     */
    _processItemChanged: function(id, doc) {
      var items = this.items;
      if (!items) {
        return this._pushHistoryItem(doc);
      }
      for (var i = 0, len = items.length; i < len; i++) {
        if (items[i]._id === id) {
          return this.set(['items', i], doc);
        }
      }
      this._pushHistoryItem(doc);
    },
    /**
     * Adds a new history item to the top of the list.
     */
    _pushHistoryItem: function(item) {
      item.hasHeader = true;
      item.header = 'Today';
      item.today = true;

      var firstItem = this.get(['items', 0]);
      if (firstItem === undefined) {
        return this.set('items', [item]);
      }

      if (firstItem && firstItem.today) {
        delete firstItem.hasHeader;
        delete firstItem.header;
        this.set(['items', 0], firstItem);
      }
      var items = [item].concat(this.items);
      this.set('items', items);
    },

    // Hanlder for the `request-object-deleted` event. Removed item from list if found.
    _requestDeleted: function(e) {
      if (e.cancelable) {
        return;
      }
      if (e.detail.type !== 'history-requests') {
        return;
      }
      var id = e.detail.id;
      var items = this.items;
      if (!items || !items.length) {
        return;
      }
      for (var i = 0, len = items.length; i < len; i++) {
        if (items[i]._id === id) {
          return this.splice('items', i, 1);
        }
      }
    },

    // Handler for the `datastore-destroyed` custom event
    _onDatabaseDestroy: function(e) {
      var datastore = e.detail.datastore;
      if (!datastore || !datastore.length) {
        return;
      }
      if (typeof datastore === 'string') {
        datastore = [datastore];
      }
      if (datastore.indexOf('history-requests') === -1 && datastore[0] !== 'all') {
        return;
      }

      this._db.close()
      .then(() => {
        this.refresh();
      });
    },
    /**
     * Computes class name for the HTML element representing a history item.
     */
    _computeItemClass: function(_id, selectedItem) {
      if (_id && _id === selectedItem) {
        return 'iron-selected';
      }
    },
    // Computes value for the `hasItems` property.
    _computeHasItems: function(length) {
      return !!(length);
    },

    /**
     * Called every time the element changed it's scroll position. It will call the `makeQuery`
     * function when there's less than 120px left to scroll. (also it must be opened and must not
     * already querying).
     */
    _scrollHandler: function() {
      if (this.querying || !this._isOpened) {
        return;
      }
      var elm = this.scrollTarget;
      var delta = elm.scrollHeight - (elm.scrollTop + elm.offsetHeight);
      if (delta < 120) {
        this.makeQuery();
      }
    },
    /**
     * The function to call when new query for data is needed.
     */
    makeQuery: function() {
      this.debounce('menu-load-history-page', this._loadPage, 20);
    },
    /**
     * Performs the query and processes the result.
     */
    _loadPage: function() {
      var db = this._db;
      this._setQuerying(true);

      db.allDocs(this.queryOptions)
      .then(response => {
        this._setQuerying(false);
        if (response && response.rows.length > 0) {
          // Set up pagination.
          this.queryOptions.startkey = response.rows[response.rows.length - 1].key;
          this.queryOptions.skip = 1;
          let res = response.rows.map(item => item.doc);
          res = this._processResults(res);
          if (!this.items) {
            this.set('items', res);
          } else {
            res.forEach(item => {
              this.push('items', item);
            });
          }
        }
      })
      .catch((e) => {
        this._setQuerying(false);
        this.fire('app-log', {
          message: ['Query menu items', e],
          level: 'error'
        });
        console.error('Query menu items', e);
      });
    },
    /**
     * Processes query results to generate view data model.
     * @param {Array} res List of history items retreived from the datastore.
     * @return {Array} Processed data items.
     */
    _processResults: function(res) {
      // updates required timestamps
      res = this._ensureTimestamps(res);
      // sorts by updated time
      res.sort(this._sortResults);
      var today = this._getTodayTimestamp();
      var yesterday = this._getYesterdayTimestamp(today);
      res = this._groupHistory(res, today, yesterday);
      return res;
    },
    /**
     * Ensures that the history objects have the `updated` property
     * required by further computations while processing results.
     *
     * @param {Array} items List of history items
     * @return {Array} The same array but all items will have `updated`
     * property.
     */
    _ensureTimestamps: function(items) {
      return items.map(item => {
        if (!item.updated || item.updated !== item.updated) {
          if (item.created && item.created === item.created) {
            item.updated = item.created;
          } else {
            item.updated = Date.now();
          }
        }
        return item;
      });
    },
    // Sorts the query results by `updated` property.
    _sortResults: function(a, b) {
      if (a.updated > b.updated) {
        return -1;
      }
      if (a.updated < b.updated) {
        return 1;
      }
      return 0;
    },

    // Creates a timestamp fot today, midnight
    _getTodayTimestamp: function() {
      var now = new Date();
      now.setMilliseconds(0);
      now.setSeconds(0);
      now.setMinutes(0);
      now.setHours(0);
      return now.getTime();
    },
    // Computes yesterday's midninght based on today's mignight timestamp
    _getYesterdayTimestamp: function(todayTimestamp) {
      return todayTimestamp - 86400000; // 24 h milliseconds
    },
    /**
     * Creates a headers for each day and group requests in each day group.
     */
    _groupHistory: function(items, today, yesterday) {
      var days = [];
      items = items.map(item => {
        let info = this._computeHistoryTime(item._id.split('/')[0]);
        if (!info) {
          return;
        }
        let date = info.formatted;
        if (days.indexOf(date) === -1) {
          days[days.length] = date;
          let time = info.time;
          if (time === today) {
            item.today = true;
            date = 'Today';
          } else if (time === yesterday) {
            date = 'Yesterday';
          }
          item.hasHeader = true;
          item.header = date;
        }
        return item;
      });
      items = items.filter(item => !!item);
      return items;
    },

    _computeHistoryTime: function(date) {
      var d = new Date(Number(date));
      var _t = d.getTime();
      if (_t !== _t) {
        return '';
      }
      var options = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      };
      return {
        formatted: new Intl.DateTimeFormat(undefined, options).format(d),
        time: _t
      };
    },

    // Computes value for the `dataUnavailable` property.
    _computeDataUnavailable: function(hasItems, querying) {
      return !hasItems && !querying;
    },
    // Handler for the `tap` event on the item.
    _openHistory: function(e) {
      var id = e.model.get('item._id');
      this.fire('navigate', {
        base: 'request',
        type: 'history',
        id: id
      });
    }
  });
  </script>
</dom-module>
