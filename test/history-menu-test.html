<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../arc-data-generator/arc-data-generator.html">
    <link rel="import" href="../history-menu.html">
    <style>
    history-menu {
      height: 600px;
    }
    </style>
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <history-menu no-auto></history-menu>
      </template>
    </test-fixture>

    <script>
    /* global DataGenerator */

    suite('History menu', () => {
      function dataFactory(e) {
        e.preventDefault();
        e.detail.result = new Promise((resolve) => {
          let data = DataGenerator.generateHistoryRequestsData({
            requestsSize: 30
          });
          data = data.map((i) => {
            return {
              doc: i,
              key: i._id
            };
          });
          resolve({
            rows: data
          });
        });
      }

      suiteSetup(() => {
        document.body.addEventListener('request-list', dataFactory);
      });

      suiteTeardown(() => {
        document.body.removeEventListener('request-list', dataFactory);
      });

      suite('Basic UI', () => {
        let element;
        setup(() => {
          element = fixture('Basic');
          return element._loadPage();
        });

        test('hasRequests is set', () => {
          assert.isTrue(element.hasRequests);
        });

        test('dataUnavailable is computed', () => {
          assert.isFalse(element.dataUnavailable);
        });

        test('Empty message is not rendered', () => {
          const node = element.shadowRoot.querySelector('.empty-message');
          assert.notOk(node);
        });

        test('The list renders children', (done) => {
          flush(() => {
            const node = element.$.list;
            assert.isAbove(node.children.length, 1);
            done();
          });
        });
      });

      suite('_computeItemClass()', () => {
        let element;
        setup(() => {
          element = fixture('Basic');
        });

        test('Returns class name when arguments matches', () => {
          const result = element._computeItemClass('a', 'a');
          assert.equal(result, 'iron-selected');
        });

        test('Returns empty string when not set', () => {
          const result = element._computeItemClass('', '');
          assert.equal(result, '');
        });

        test('Returns empty string when arguments do not match', () => {
          const result = element._computeItemClass('a', 'b');
          assert.equal(result, '');
        });
      });

      suite('_scrollHandler()', () => {
        let element;
        setup(() => {
          element = fixture('Basic');
          return element._loadPage();
        });

        test('Does nothin when querying', () => {
          element._setQuerying(true);
          const spy = sinon.spy(element, 'loadNext');
          element._scrollHandler();
          assert.isFalse(spy.called);
        });

        test('Does nothing when scroll treshold is not reached', (done) => {
          flush(() => {
            const spy = sinon.spy(element, 'loadNext');
            element._scrollHandler();
            assert.isFalse(spy.called);
            done();
          });
        });

        test('Calls loadNext() when scroll treshold is reached', (done) => {
          flush(() => {
            const spy = sinon.spy(element, 'loadNext');
            const node = element.$.list;
            node.scrollTop = node.scrollHeight;
            element._scrollHandler();
            assert.isTrue(spy.called);
            done();
          });
        });
      });

      suite('_openHistory()', () => {
        let element;
        setup(() => {
          element = fixture('Basic');
          return element._loadPage();
        });

        test('Dispatches navigate event', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.isTrue(spy.called);
            done();
          });
        });

        test('The event bubbles', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.isTrue(spy.args[0][0].bubbles);
            done();
          });
        });

        test('The event has base', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.equal(spy.args[0][0].detail.base, 'request');
            done();
          });
        });

        test('The event has type', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.equal(spy.args[0][0].detail.type, 'history');
            done();
          });
        });

        test('The event has id', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.equal(spy.args[0][0].detail.id, element.requests[0]._id);
            done();
          });
        });
      });
    });
    </script>

  </body>
</html>
