<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../node_modules/mocha/mocha.js"></script>
    <script src="../node_modules/chai/chai.js"></script>
    <script src="../node_modules/wct-mocha/wct-mocha.js"></script>

    <style>
    history-menu {
      height: 600px;
    }
    </style>
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <history-menu no-auto></history-menu>
      </template>
    </test-fixture>

    <test-fixture id="Draggable">
      <template>
        <history-menu no-auto draggable-enabled></history-menu>
      </template>
    </test-fixture>

    <script type="module">
    import {DataGenerator} from '../../../@advanced-rest-client/arc-data-generator/arc-data-generator.js';
    import sinon from '../../../sinon/pkg/sinon-esm.js';
    import {afterNextRender} from '../../../@polymer/polymer/lib/utils/render-status.js';
    import '../history-menu.js';
    /* global DataTransfer */

    // DataTransfer polyfill
    if (typeof DataTransfer === 'undefined') {
      class DataTransfer {
        setData(type, data) {
          this._data[type] = data;
        }
        getData(type) {
          if (!this._data) {
            return null;
          }
          return this._data[type];
        }
      }
      window.DataTransfer = DataTransfer;
    }

    suite('History menu', () => {
      function dataFactory(e) {
        e.preventDefault();
        e.detail.result = new Promise((resolve) => {
          let data = DataGenerator.generateHistoryRequestsData({
            requestsSize: 30
          });
          data = data.map((i) => {
            return {
              doc: i,
              key: i._id
            };
          });
          resolve({
            rows: data
          });
        });
      }

      suiteSetup(() => {
        document.body.addEventListener('request-list', dataFactory);
      });

      suiteTeardown(() => {
        document.body.removeEventListener('request-list', dataFactory);
      });

      suite('Basic UI', () => {
        let element;
        setup(() => {
          element = fixture('Basic');
          return element._loadPage();
        });

        test('hasRequests is set', () => {
          assert.isTrue(element.hasRequests);
        });

        test('dataUnavailable is computed', () => {
          assert.isFalse(element.dataUnavailable);
        });

        test('Empty message is not rendered', () => {
          const node = element.shadowRoot.querySelector('.empty-message');
          assert.notOk(node);
        });

        test('The list renders children', (done) => {
          flush(() => {
            const node = element.$.list;
            assert.isAbove(node.children.length, 1);
            done();
          });
        });
      });

      suite('_computeItemClass()', () => {
        let element;
        setup(() => {
          element = fixture('Basic');
        });

        test('Returns class name when arguments matches', () => {
          const result = element._computeItemClass('a', 'a');
          assert.equal(result, 'iron-selected');
        });

        test('Returns empty string when not set', () => {
          const result = element._computeItemClass('', '');
          assert.equal(result, '');
        });

        test('Returns empty string when arguments do not match', () => {
          const result = element._computeItemClass('a', 'b');
          assert.equal(result, '');
        });
      });

      suite('_scrollHandler()', () => {
        let element;
        setup(() => {
          element = fixture('Basic');
          return element._loadPage();
        });

        test('Does nothin when querying', () => {
          element._setQuerying(true);
          const spy = sinon.spy(element, 'loadNext');
          element._scrollHandler();
          assert.isFalse(spy.called);
        });

        test('Does nothing when scroll treshold is not reached', (done) => {
          flush(() => {
            const spy = sinon.spy(element, 'loadNext');
            element._scrollHandler();
            assert.isFalse(spy.called);
            done();
          });
        });

        test('Calls loadNext() when scroll treshold is reached', (done) => {
          flush(() => {
            const spy = sinon.spy(element, 'loadNext');
            const node = element.$.list;
            node.scrollTop = node.scrollHeight;
            element._scrollHandler();
            assert.isTrue(spy.called);
            done();
          });
        });
      });

      suite('_openHistory()', () => {
        let element;
        setup(() => {
          element = fixture('Basic');
          return element._loadPage();
        });

        test('Dispatches navigate event', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.isTrue(spy.called);
            done();
          });
        });

        test('The event bubbles', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.isTrue(spy.args[0][0].bubbles);
            done();
          });
        });

        test('The event has base', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.equal(spy.args[0][0].detail.base, 'request');
            done();
          });
        });

        test('The event has type', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.equal(spy.args[0][0].detail.type, 'history');
            done();
          });
        });

        test('The event has id', (done) => {
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            const spy = sinon.spy();
            element.addEventListener('navigate', spy);
            node.click();
            assert.equal(spy.args[0][0].detail.id, element.requests[0]._id);
            done();
          });
        });
      });

      suite('_computeDraggableValue()', () => {
        let element;
        setup(function() {
          element = fixture('Basic');
        });

        test('Returns "true" when draggableEnabled is set', () => {
          const result = element._computeDraggableValue(true);
          assert.equal(result, 'true');
        });

        test('Returns "false" when draggableEnabled is not set', () => {
          const result = element._computeDraggableValue(false);
          assert.equal(result, 'false');
        });

        test('Request item has dragging disabled by default', (done) => {
          element.requests = [DataGenerator.generateSavedItem()];
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            assert.equal(node.getAttribute('draggable'), 'false');
            done();
          });
        });

        test('Request item has dragging enabled', (done) => {
          element.draggableEnabled = true;
          element.requests = [DataGenerator.generateHistoryObject()];
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            assert.equal(node.getAttribute('draggable'), 'true');
            done();
          });
        });
      });

      suite('_dragStart()', () => {
        let element;
        setup(function(done) {
          element = fixture('Draggable');
          element.requests = DataGenerator.generateHistoryRequestsData({
            requestsSize: 2
          });
          // next frame by history-list-mixin
          afterNextRender(element, () => {
            // database query
            setTimeout(() => {
              // Polymer stamp
              flush(() => done());
            });
          });
        });

        function dispatch(element) {
          const node = element.shadowRoot.querySelector('paper-icon-item');
          const e = new Event('dragstart');
          e.dataTransfer = new DataTransfer();
          node.dispatchEvent(e);
        }

        test('Calls _dragStart()', () => {
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          assert.isTrue(spy.called);
        });

        test('Sets arc/request-object transfer data', () => {
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          const data = spy.args[0][0].dataTransfer.getData('arc/request-object');
          assert.typeOf(data, 'string');
        });

        test('Sets arc/history-request data', () => {
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          const data = spy.args[0][0].dataTransfer.getData('arc/history-request');
          assert.equal(data, element.requests[0]._id);
        });

        test('Sets arc-source/history-menu transfer data', () => {
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          const data = spy.args[0][0].dataTransfer.getData('arc-source/history-menu');
          assert.equal(data, element.requests[0]._id);
        });

        test('Ignores event when draggableEnabled not set', () => {
          element.draggableEnabled = false;
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          assert.isUndefined(spy.args[0][0].dropEffect);
        });

        test('Ignores event when draggableEnabled not set', () => {
          element.draggableEnabled = false;
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          assert.isUndefined(spy.args[0][0].dropEffect);
        });
      });
    });
    </script>

  </body>
</html>
